# HKDSE Geometry Animation API (Manim Community v0.18, Black Background)

## 0. Environment and Base Class

All generated scenes must:

- Use Manim Community v0.18.
- Subclass `CScene`.
- Assume:
  - Static camera.
  - Black background.
  - `MathTex` only (no full sentences).
  - No label longer than 3 characters.
  - Max ~20 seconds per animation, 4–5 beats.

### Color Scheme (semantic)

- Angle of interest / focused point: `YELLOW`
- Hypotenuse: `RED`
- Opposite side: `BLUE`
- Adjacent side: `GREEN`
- Auxiliary / construction: `GRAY` or `GRAY_D`
- Other lines: `WHITE` or `BLUE_B`

### Disallowed / discouraged

- Do not clear the whole scene (no “wipe”).
- Do not use fast camera shakes or extreme zooms.
- Prefer `Transform` or dimming (`set_opacity`) over `FadeOut` when changing focus.

***

## 1. Base Scene: `CScene`

All template methods are instance methods of this class. A typical scene:

```python
from manim import *
from hkdse_geometry_base import CScene
import numpy as np

class ExampleScene(CScene):
    def construct(self):
        self.setup_scene("Title")
        # call templates and/or low-level primitives here
```

### 1.1 Scene / Layout Helpers

#### `setup_scene(title: str, subtitle: str | None = None) -> VGroup`
Create and display a title (and optional subtitle) at the top.

- `title`: Main title text.
- `subtitle`: Optional subtitle.
- Returns: `VGroup` containing title elements.

Usage:

```python
title_group = self.setup_scene("Right Triangle Sides")
```

#### `pause(t: float = 0.5) -> None`
Wrapper around `self.wait(t)`.

Usage:

```python
self.pause()      # 0.5s
self.pause(1.5)   # 1.5s
```

#### `play_steps(*anims, run_time: float = 1.0, rate_func=smooth) -> None`
Standardized `self.play` with default timing.

Usage:

```python
self.play_steps(Create(triangle))
self.play_steps(Indicate(hyp_line), run_time=1.5)
```

***

### 1.2 Text and Labels

#### `mtex(s: str, scale: float = 0.9, color=None) -> MathTex`
Create styled `MathTex`.

- `s`: LaTeX string.
- `scale`: Scale factor.
- `color`: Optional color.

Usage:

```python
eq = self.mtex(r"\sin A = \frac{\text{opp}}{\text{hyp}}")
```

#### `label_point(dot: Mobject, name: str, direction=UR, buff: float = 0.15, font_size: int = 28) -> Text`
Place a short label near a point.

- `name`: ≤ 3 characters (e.g., `"A"`, `"B"`, `"C"`).

Usage:

```python
A_label = self.label_point(A_dot, "A")
```

#### `label_line(line: Line, text: str, offset=UP, buff: float = 0.15, font_size: int = 26) -> Text`
Label a line/segment at its midpoint.

- `text`: ≤ 3 characters (e.g., `"hyp"`, `"opp"`, `"adj"`, `"a"`, `"b"`).

Usage:

```python
self.label_line(hyp_line, "hyp", offset=UR)
```

#### `show_equation_step(prev: Mobject | None, new_latex: str, to_edge_dir=DOWN, buff: float = 0.4) -> MathTex`
Manage step‑by‑step equation display.

- If `prev is None`, writes the first equation.
- Otherwise transforms `prev` into the new equation.
- Returns the current equation object for chaining.

Usage:

```python
eq = None
eq = self.show_equation_step(eq, r"h = b \sin C")
eq = self.show_equation_step(eq, r"\text{Area} = \frac{1}{2}ab\sin C")
```

***

### 1.3 Coordinate Plane Helpers

#### `make_plane(x_range=[-6, 6, 1], y_range=[-4, 4, 1], x_length: float = 10, y_length: float = 6, show_numbers: bool = True) -> NumberPlane`
Create a `NumberPlane` with consistent style.

Usage:

```python
plane = self.make_plane()
```

#### `to_xy(plane: NumberPlane, x: float, y: float) -> np.ndarray`
Convert coordinate pair to scene point via `plane.c2p`.

Usage:

```python
P = self.to_xy(plane, 2, 3)
```

#### `plot_point(plane: NumberPlane, x: float, y: float, color=None, radius: float = 0.06) -> Dot`
Place a dot at `(x, y)` on the plane.

Usage:

```python
P_dot = self.plot_point(plane, 2, 3)
self.label_point(P_dot, "P")
```

***

### 1.4 Static Geometric Constructions

#### `segment(A: np.ndarray, B: np.ndarray, color=None, stroke_width: float = 4, dashed: bool = False) -> Line`
Create a line segment from `A` to `B`.

Usage:

```python
AB = self.segment(A, B)
aux = self.segment(A, C, dashed=True)
```

#### `ray(A: np.ndarray, B: np.ndarray, length: float = 6, color=None, stroke_width: float = 4) -> Line`
Create a ray starting at `A` through `B`.

Usage:

```python
r = self.ray(O, P)
```

#### `polygon(*points: np.ndarray, color=None, stroke_width: float = 4, fill_opacity: float = 0.0) -> Polygon`
Create a polygon (triangle, quadrilateral, etc.).

Usage:

```python
triangle = self.polygon(A, B, C)
quad = self.polygon(A, B, C, D)
```

#### `circle_from_center_radius(center: np.ndarray, r: float, color=None, stroke_width: float = 4) -> Circle`
Create a circle with given centre and radius.

Usage:

```python
circle = self.circle_from_center_radius(ORIGIN, 2.5)
```

#### `angle_mark(A: np.ndarray, O: np.ndarray, B: np.ndarray, radius: float = 0.4, color=YELLOW, label: str | None = None, label_offset: float = 0.2, label_font_size: int = 26) -> VGroup`
Draw an angle arc ∠AOB, optionally with a label (≤ 3 characters).

Usage:

```python
theta = self.angle_mark(B, A, C, color=YELLOW, label="A")
```

#### `right_angle_mark(A: np.ndarray, O: np.ndarray, B: np.ndarray, size: float = 0.25, color=YELLOW) -> Polygon`
Draw a right‑angle square at vertex O.

Usage:

```python
right_mark = self.right_angle_mark(B, A, C)
```

#### `distance_brace(A: np.ndarray, B: np.ndarray, label: str | None = None, label_font_size: int = 26, color=WHITE) -> VGroup`
Draw a brace between two points, with optional short label.

Usage:

```python
brace = self.distance_brace(A, B, label="AB")
```

***

### 1.5 Dynamic / Drag‑a‑Point Helpers

These use updaters/`always_redraw`.

#### `tracker(x0: float) -> ValueTracker`
Create a scalar `ValueTracker` for parameters like angle or x‑coordinate.

Usage:

```python
t = self.tracker(0.0)
self.play(t.animate.set_value(PI))
```

#### `dynamic_point_on_plane(plane: NumberPlane, x_tracker: ValueTracker, y_tracker: ValueTracker, color=None, radius: float = 0.06) -> Dot`
Dot that moves with trackers `(x(t), y(t))`.

Usage:

```python
xt = self.tracker(1.0)
yt = self.tracker(2.0)
moving_dot = self.dynamic_point_on_plane(plane, xt, yt)
self.play(xt.animate.set_value(3), yt.animate.set_value(-1))
```

#### `dynamic_line(get_A, get_B, color=None, stroke_width: float = 4) -> Line`
Line that always connects `get_A()` to `get_B()`.

- `get_A`, `get_B`: Callables returning `np.ndarray`.

Usage:

```python
def get_A(): return A_dot.get_center()
def get_B(): return B_dot.get_center()
AB_line = self.dynamic_line(get_A, get_B)
```

#### `dynamic_circle_center_point(get_center, get_point, color=None, stroke_width: float = 4) -> Circle`
Circle defined by moving centre and point on the circle.

Usage:

```python
circle = self.dynamic_circle_center_point(
    get_center=lambda: C_dot.get_center(),
    get_point=lambda: P_dot.get_center(),
)
```

#### `dynamic_angle(get_A, get_O, get_B, radius: float = 0.4, color=YELLOW) -> Angle`
Angle that updates as three points move.

Usage:

```python
dyn_angle = self.dynamic_angle(
    get_A=lambda: A_dot.get_center(),
    get_O=lambda: O_dot.get_center(),
    get_B=lambda: B_dot.get_center(),
)
```

#### `freeze_updaters(*mobs: Mobject) -> None` / `unfreeze_updaters(*mobs: Mobject) -> None`
Suspend/resume mobject updating.

Usage:

```python
self.freeze_updaters(moving_dot, dyn_line)
# do transformations
self.unfreeze_updaters(moving_dot, dyn_line)
```

***

### 1.6 HKDSE “Lesson Atom” Helpers

#### `theorem_card(name: str, statement_latex: str, diagram: Mobject) -> VGroup`
Create a framed theorem card (title + statement + diagram).

Usage:

```python
card = self.theorem_card(
    "Same Segment",
    r"\angle ACB = \angle ADB",
    diagram_group
)
```

#### `proof_skeleton(givens: list[str], to_prove: str) -> VGroup`
Show “Given / To prove” text layout.

Usage:

```python
info = self.proof_skeleton(
    [r"A,B,C,D \text{ concyclic}", r"AC \cap BD = E"],
    r"\angle AEC = \angle ABC"
)
```

#### `locus_traced_path(moving_dot: Dot, color=ORANGE, stroke_width: float = 3) -> TracedPath`
Trace the path of a moving point.

Usage:

```python
path = self.locus_traced_path(moving_dot)
```

#### `coordinate_solution_template(problem_latex: str, steps: list[str], final_latex: str) -> VGroup`
Standard layout for coordinate‑geometry solution steps.

Usage:

```python
group = self.coordinate_solution_template(
    r"Find equation of circle with centre (1,-2) radius 5.",
    [
        r"(x-1)^2+(y+2)^2=25",
        r"x^2-2x+1+y^2+4y+4=25"
    ],
    r"x^2+y^2-2x+4y-20=0"
)
```

***

## 2. High‑Level HKDSE Trigonometry Templates

These encapsulate complete ~20s animations with 4–5 beats. Use them directly when the slide concept matches.

### 2.1 Right‑Triangle Ratios

#### `animate_right_triangle_ratios(self, focus_angle: str = "A", highlight_sequence: list[str] = ["hyp", "opp", "adj"], show_ratio_equations: bool = False) -> None`
Explain hypotenuse, opposite, and adjacent relative to a chosen angle.

- `focus_angle`: `"A"` or `"B"`.
- `highlight_sequence`: Order of side highlighting (e.g., `["hyp","opp","adj"]`).
- `show_ratio_equations`: Whether to show `sin`, `cos`, `tan` equations.

Typical use:

```python
self.animate_right_triangle_ratios(
    focus_angle="A",
    highlight_sequence=["hyp", "opp", "adj"]
)
```

***

### 2.2 Trig Ratio Values at a Given Angle

#### `animate_trig_ratio_values(self, angle_degrees: float = 30, ratios: list[str] = ["sin", "cos", "tan"]) -> None`
Show numerical values of `sin`, `cos`, `tan` for a specific angle (useful for 30°, 45°, 60°).

- `angle_degrees`: Angle in degrees.
- `ratios`: List of `"sin"`, `"cos"`, `"tan"` to display.

Usage:

```python
self.animate_trig_ratio_values(30, ["sin", "cos"])
```

***

### 2.3 Sine Graph Properties

#### `animate_sine_wave_properties(self, show_amplitude: bool = True, show_period: bool = True) -> None`
Illustrate key properties of the sine graph: max/min and period.

- `show_amplitude`: Mark maximum and minimum values.
- `show_period`: Mark one full period with a brace.

Usage:

```python
self.animate_sine_wave_properties(show_amplitude=True, show_period=True)
```

***

### 2.4 Area Formula \( \text{Area} = \frac{1}{2}ab\sin C \)

#### `animate_triangle_area_formula(self, side_a: float = 4, side_b: float = 3, angle_C_degrees: float = 60) -> None`
Show how dropping a height leads to the area formula.

- `side_a`, `side_b`: The two sides forming the included angle.
- `angle_C_degrees`: Included angle \(C\).

Usage:

```python
self.animate_triangle_area_formula(side_a=4, side_b=3, angle_C_degrees=60)
```

***

### 2.5 Sine Rule

#### `animate_sine_rule(self, triangle_angles: tuple[float, float, float] = (30, 60, 90)) -> None`
Demonstrate \( \frac{a}{\sin A} = \frac{b}{\sin B} = \dots \).

- `triangle_angles`: `(A°, B°, C°)`.

Usage:

```python
self.animate_sine_rule(triangle_angles=(30, 60, 90))
```

***

### 2.6 Cosine Rule

#### `animate_cosine_rule(self, side_a: float = 5, side_b: float = 4, angle_C_degrees: float = 60) -> None`
Show \( c^2 = a^2 + b^2 - 2ab\cos C \) and highlight side \(c\).

- `side_a`, `side_b`: Known sides.
- `angle_C_degrees`: Included angle \(C\).

Usage:

```python
self.animate_cosine_rule(side_a=5, side_b=4, angle_C_degrees=60)
```

***

### 2.7 3D: Angle Between Lines

#### `animate_3d_angle_between_lines(self, show_projection: bool = True) -> None`
2D representation of angle between two lines in 3D, with optional projection.

- `show_projection`: Whether to visualize projections on base plane.

Usage:

```python
self.animate_3d_angle_between_lines(show_projection=True)
```

***

### 2.8 3D: Angle Between Line and Plane

#### `animate_angle_line_to_plane(self) -> None`
Show angle between a line and a plane via perpendicular projection.

Usage:

```python
self.animate_angle_line_to_plane()
```

***

### 2.9 Solving Trig Equations on Unit Circle

#### `animate_solve_trig_equation(self, equation_latex: str = r"\sin \theta = 0.5", solutions_degrees: list[float] = [30, 150]) -> None`
Visualize solutions to a trig equation on the unit circle, over \(0° \leq \theta \leq 360°\).

- `equation_latex`: Equation to display.
- `solutions_degrees`: List of solution angles in degrees.

Usage:

```python
self.animate_solve_trig_equation(
    equation_latex=r"\sin \theta = \frac{1}{2}",
    solutions_degrees=[30, 150]
)
```

***

## 3. Usage Pattern for the LLM

For each slide:

1. Identify the **single main concept**.
2. If a matching high‑level template exists, **call that template** with suitable parameters.
3. If no template fits, use **low‑level primitives** (`segment`, `polygon`, `angle_mark`, etc.) while respecting:
   - 4–5 beats.
   - ≤ 20 seconds.
   - Color/label rules.
   - Prefer `Transform`/dimming over scene-clearing.

Example generated scene for a slide about right‑triangle sides:

```python
class RightTriangleSidesScene(CScene):
    def construct(self):
        self.setup_scene("Right Triangle Sides")
        self.animate_right_triangle_ratios(
            focus_angle="A",
            highlight_sequence=["hyp", "opp", "adj"],
            show_ratio_equations=False
        )
```